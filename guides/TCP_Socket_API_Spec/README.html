<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>TCP Socket API Spec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta content="Scroll EclipseHelp Exporter" name="generator" />
<link type="text/css" rel="stylesheet" />
<link type="text/css" rel="stylesheet" />
<link type="text/css" rel="stylesheet" media="print" />
</head>
<body>
<div class="container">
<div class="header"></div>
<div id="29004739" class="content"><a id="editButton" href="https://wiki.appcelerator.org/pages/editpage.action?pageId=29004739"><span>Edit</span></a>
<h1>TCP Socket API Spec</h1>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Contents">
<h2 class="heading "><span>Contents</span></h2>
<p>
</p>
<ul class="toc-indentation "><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Overview" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Overview="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Overview">Overview</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-ConceptsandDefinitions" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-ConceptsandDefinitions="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-ConceptsandDefinitions">Concepts and Definitions</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Basisofspec" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Basisofspec="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Basisofspec">Basis of spec</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Namespacing" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Namespacing="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Namespacing">Namespacing</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Transportlayersupport" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Transportlayersupport="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Transportlayersupport">Transport layer support</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Socketlifecycle" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Socketlifecycle="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Socketlifecycle">Socket lifecycle</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Connecting%28outbound%29sockets" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Connecting%28outbound%29sockets="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Connecting%28outbound%29sockets">Connecting (outbound) sockets</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Listening%28accepting%29sockets" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Listening%28accepting%29sockets="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Listening%28accepting%29sockets">Listening (accepting) sockets</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Acceptedsockets" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Acceptedsockets="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Acceptedsockets">Accepted sockets</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-ChangestoexistingTi.Network.TCPSocketoniOS" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-ChangestoexistingTi.Network.TCPSocketoniOS="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-ChangestoexistingTi.Network.TCPSocketoniOS">Changes to existing Ti.Network.TCPSocket on iOS</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Securityissues" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Securityissues="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Securityissues">Security issues</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-INADDR_ANY" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-INADDR_ANY="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-INADDR_ANY">INADDR_ANY</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-I%2FOLayer" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-I%2FOLayer="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-I%2FOLayer">I/O Layer</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-ProposedAPI" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-ProposedAPI="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-ProposedAPI">Proposed API</a> </p>
<ul class="toc-indentation "><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Ti.Network" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Ti.Network="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Ti.Network">Ti.Network</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Ti.Network.Socket" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Ti.Network.Socket="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Ti.Network.Socket">Ti.Network.Socket</a> </p>
</li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-Ti.Network.Socket.TCP" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Ti.Network.Socket.TCP="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-Ti.Network.Socket.TCP">Ti.Network.Socket.TCP</a> </p>
</li></ul></li><li class=" "> <p>
<a class="document-link " href="#!/guide/TCP_Socket_API_Spec-section-29004739_TCPSocketAPISpec-PseudoCodeExamples" TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-PseudoCodeExamples="TCP_Socket_API_Spec.html#29004739_TCPSocketAPISpec-PseudoCodeExamples">Pseudo Code Examples</a> </p>
</li></ul> </div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Overview">
<h2 class="heading "><span>Overview</span></h2>
<p>
Sockets have been a part of the iOS networking infrastructure for over a year, and while their implementation has been satisfactory enough to allow users to add more advanced networking support beyond single-session HTTP requests to their products, there is room for improvement. Currently there are many problems with the iOS implementation of TCP sockets, most notabily with data chunking, the usage of an event-based system, insufficient distinction between 'listening' (accepts incoming connections) and 'connecting' (represents outbound connection) types, and inconsistent representation of sockets (some are objects, some are BSD file descriptors).    </p>
<p>
With the advent of sockets for Android, this is an ideal opportunity to address these issues and make sockets able to integrate future technologies, such as I/O streaming (or to represent an I/O stream themselves as a ducktype) and zero-configuration networking support for Android.    </p>
<p>
Where possible, comparisons will be drawn to the existing socket implementation on iOS and the proposed spec.    </p>
<p>
It should be noted that this spec is in flux based on the pending definition of the IO stream spec. Major changes are not expected, but further changes are possible.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-ConceptsandDefinitions">
<h2 class="heading "><span>Concepts and Definitions</span></h2>
<ul class=" "><li class=" "> <p>
Socket: A socket is essentially a data stream that is connected to a host/port pair.    </p>
</li><li class=" "> <p>
Transport layer: The portion of a networking protocol which determines the parameters of data transmission (reliability, streaming, multiplexing, etc.) The two most common are UDP and TCP.    </p>
</li><li class=" "> <p>
BSD sockets: The standard POSIX implementation of sockets.    </p>
</li><li class=" "> <p>
INADDR_ANY: A specialized BSD host identifier for listening sockets which indicates that ALL available local network interfaces should be listened on. Practically, for us, this means sockets would listen on loopback (127.0.0.1), wifi, and data network.    </p>
</li><li class=" "> <p>
Listener: A socket which actively listens on a specified host/port for incoming connections.    </p>
</li><li class=" "> <p>
Connector: A socket which connects to a specified host/port.    </p>
</li></ul> <p>
Throughout this document, except where specified, the word &quot;socket&quot; indicates a socket that uses the TCP transport layer.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Basisofspec">
<h2 class="heading "><span>Basis of spec</span></h2>
<p>
The basis of the spec, from an outward facing functionality standpoint, is the <a class="external-link external-link" href="http://en.wikipedia.org/wiki/Berkeley_sockets" target="_blank">BSD socket specification</a>. Functions, where possible, correspond directly to their BSD counterparts.    </p>
<p>
The reason for this is to keep the interface simple, flexible, minimal, and familiar to developers who may already have experience with developing networking code. Events fired based on the socket lifecycle state (see below) provide the opportunity for more advanced handling than the standard C paradigm and allow a BSD-like interface to fit comfortably into Titanium.    </p>
<p>
There is precedence for this, as the iOS TCPSocket presents a stripped-down version of the BSD interface with some magic.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Namespacing">
<h2 class="heading "><span>Namespacing</span></h2>
<p>
It is proposed that we create a new <tt class=" ">Ti.Network.Socket</tt> namespace within <tt class=" ">Ti.Network</tt>, which will house socket objects which correspond to different transport layers. The rationale for this is as follows:    </p>
<ul class=" "><li class=" "> <p>
Certain socket transport types (in particular, UDP) are incompatible with TCP from an interface standpoint. In particular, UDP sockets use a &quot;datagram&quot; model in which there are no listening/connecting sockets, and they do not behave as I/O streams.    </p>
</li><li class=" "> <p>
The name <tt class=" ">Ti.Network.TCPSocket</tt> is currently reserved on iOS and cannot be deprecated until a later time (see below). This makes it impractical to use the <tt class=" ">Ti.Network</tt> namespace as a container for TCPSocket, UDPSocket, etc.    </p>
</li><li class=" "> <p>
This allows us to reserve a specific namespace for implementation of further transport layers, and give users a convenient space to present any custom transport layers they implement.    </p>
</li></ul> </div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Transportlayersupport">
<h2 class="heading "><span>Transport layer support</span></h2>
<p>
As per this spec, only <tt class=" ">Ti.Network.Socket.TCP</tt> (TCP support) will be initially available. There are plans to introduce UDP sockets, but that will be covered in a separate spec.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Socketlifecycle">
<h2 class="heading "><span>Socket lifecycle</span></h2>
<p>
A socket goes through three distinct states through its lifecycle, with one additional state to represent errors. 2a and 2b are mutually exclusive.    </p>
<p>
As follows:    </p>
<p>
1. <tt class=" ">INITIALIZED</tt> : The socket is ready to have either <tt class=" ">connect()</tt> or <tt class=" ">listen()</tt> called.<br />2a. <tt class=" ">CONNECTED</tt> : The socket is connected to its specified host/port. Set before the <tt class=" ">connected</tt> callback is called.<br />2b. <tt class=" ">LISTENING</tt> : The socket is listening on its specified host/port.<br />3. <tt class=" ">CLOSED</tt> : The socket has been cleaned up via a call to <tt class=" ">close()</tt>. A socket in this state may be re-initialized via a new call to <tt class=" ">connect()</tt> or <tt class=" ">listen()</tt>.<br />4. <tt class=" ">ERROR</tt> : The socket encountered an error. A socket in this state may be re-initialized via a new call to <tt class=" ">connect()</tt> or <tt class=" ">listen()</tt>. The <tt class=" ">error</tt> callback is called if the socket was in either the <tt class=" ">LISTENING</tt> or <tt class=" ">CONNECTED</tt> state when the error occurred.  When a socket enters an ERROR state, the socket is closed.    </p>
<p>
Currently, iOS TCPSocket only has the concept of a socket being valid. Distinct states provide the user with more information regarding the socket lifecycle, give clearly defined points at which callbacks are triggered, and also allow us to prevent reuse of sockets (undesirable in the case of connections accepted by a listener).    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Connecting(outbound)sockets">
<h2 class="heading "><span>Connecting (outbound) sockets</span></h2>
<p>
Connecting sockets are straightforward; they connect to the specified host/port endpoint and act as I/O streams (both read and write) to that endpoint. A user-created socket enters the CONNECTED state by calling <tt class=" ">connect()</tt> on it.    </p>
<p>
All operations other than <tt class=" ">listen()</tt> and <tt class=" ">accept()</tt> are valid on a connecting socket.    </p>
<p>
This is equivalent to how a connecting socket functions under iOS TCPSocket.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Listening(accepting)sockets">
<h2 class="heading "><span>Listening (accepting) sockets</span></h2>
<p>
Listening sockets accept incoming connections. A user-created socket enters the <tt class=" ">LISTENING</tt> state by calling <tt class=" ">listen()</tt> on it. The user is responsible for manually accepting incoming connections with the <tt class=" ">accept()</tt> command, which flags the socket to accept the next incoming connection (however, unlike BSD, it does not block). The rationale behind giving users control over inbound connection acceptance is to allow fine-grained control over system resources; in particular, due to the limitations of mobile device network device speeds or the OS, the user may want to only allow a limited number of concurrent connections at one time.    </p>
<p>
A listening socket <strong class=" ">only</strong> may have the <tt class=" ">accept()</tt> and <tt class=" ">close()</tt> operations called on it.    </p>
<p>
This is distinctly different from how iOS TCPSocket handles listening right now. In particular, iOS listening sockets both auto accept all incoming connections and act as a &quot;hub&quot; for all connections, rather than creating distinct socket objects for them; this introduces peculiarities such as associating file descriptors, rather than objects, with read/write data, and allowing the listener to &quot;broadcast&quot; information to all of its connected sockets. No such functionality will exist in the new socket implementation.    </p>
<p>
This current implementation is inefficient, cumbersome, presents a fragmented interface, and does not conform to what developers with network experience would consider a standard socket interface. These are all excellent reasons for changing existing behavior.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Acceptedsockets">
<h2 class="heading "><span>Accepted sockets</span></h2>
<p>
Sockets which are connecting to the local host as an endpoint are created when a listening socket accepts a new connection. These sockets arrive in the CONNECTED state and are functionally equivalent to outbound sockets.    </p>
<p>
Currently, iOS TCPSocket represents inbound sockets as file descriptors. This is unacceptable.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-ChangestoexistingTi.Network.TCPSocketoniOS">
<h2 class="heading "><span>Changes to existing  Ti.Network.TCPSocket  on iOS</span></h2>
<p>
For the present, <tt class=" ">Ti.Network.TCPSocket</tt> will remain as-is on iOS, and continue to be the only way to interface with <tt class=" ">Ti.Network.BonjourClient</tt> and <tt class=" ">Ti.Network.BonjourBrowser</tt> as these are iOS-only features. For release 1.7.0 <tt class=" ">Ti.Network.TCPSocket</tt> will <strong class=" ">not</strong> become     <span style="color: #ff0000;">
deprecated    </span>
 (due to it being the exclusive way to interface with other iOS-only features). There will not be a <tt class=" ">Ti.Network.TCPSocket</tt> namespace alias backported to Android as these sockets behave in a fundamentally different manner.    </p>
<p>
<tt class=" ">Ti.Network.TCPSocket</tt> will not be removed until there is Bonjour/Zero-configuration networking support for Android. At this point it will become     <span style="color: #ff0000;">
deprecated    </span>
 for removal in the following release.    </p>
<p>
Due to the fundamental differences in interface and operation, there is no plan to provide a transitional bridge from <tt class=" ">Ti.Network.TCPSocket</tt> to <tt class=" ">Ti.Network.Socket</tt> at any point on iOS.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-Securityissues">
<h2 class="heading "><span>Security issues</span></h2>
<p>
Presenting sockets to the world introduces a host of security issues, including but not limited to malicious data injection via a connection over the CDN (celluar data network) via a host listening on the IP address assigned to the radio (or, equivalently, via <tt class=" ">INADDR_ANY</tt>). In order to try and reduce the potency of these attacks, or the ability to conduct them, we should consider:    </p>
<ul class="alternate "><li class=" "> <p>
Revoking access to any connection that comes in directly to the CDN. <strong class=" ">NOTE</strong>: This is not necessarily feasible; socket implementations on both iOS and Android contain information about the originating host, but not necessarily the interface the connection came in over.    </p>
</li><li class=" "> <p>
Disallowing <tt class=" ">INADDR_ANY</tt> </p>
</li><li class=" "> <p>
Limiting the possibility for standard attacks (i.e. buffer overflow)    </p>
</li><li class=" "> <p>
Providing specialized training for end developers specifically for advanced network programming    </p>
</li></ul> <p>
It is worth noting that on iOS, an application listening over the CDN <strong class=" ">is</strong> considered grounds for rejection.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-INADDR_ANY">
<h2 class="heading "><span>INADDR_ANY</span></h2>
<p>
As above, we do not support BSD's <tt class=" ">INADDR_ANY</tt>. References to it are included in the spec for historical reasons and to clarify why it is not supported. In particular, we have no way to filter connections (inbound or outbound) based on the CDN, and <tt class=" ">INADDR_ANY</tt> is global with no scoping, meaning we can't have it translate to &quot;all interfaces except for CDN.&quot; For these reasons, support for this feature is     <span style="color: #ff0000;">
removed    </span>
.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-I/OLayer">
<h2 class="heading "><span>I/O Layer</span></h2>
<p>
I/O is intended to be handled entirely through <a class="document-link " href="#!/guide/Stream_Spec" Stream_Spec.html="Stream_Spec.html">Streams</a> and <a class="document-link " href="#!/guide/Buffer_Spec" Buffer_Spec.html="Buffer_Spec.html">Buffers</a>. For this reason no I/O operations are specified in this document.    </p>
<p>
The I/O Layer is intended to only be available on CONNECTED sockets. I/O does not make sense on LISTENING sockets, and sockets in the ERROR state do not have an &quot;active&quot; buffer.    </p>
<p>
The current iOS TCPSocket does not present a unified I/O layer with any other interface, and also confuses availability of I/O on LISTENING and CONNECTED sockets, and handles it in a clumsy way.    </p>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-ProposedAPI">
<h2 class="heading "><span>Proposed API</span></h2>
<div class="section section-3 " id="29004739_TCPSocketAPISpec-Ti.Network">
<h3 class="heading "><span>Ti.Network</span></h3>
<ul class=" "><li class=" "> <p>
Namespace    </p>
<ul class=" "><li class=" "> <p>
<tt class=" ">Ti.Network.Socket</tt> : Namespace for all socket types and related constants.    </p>
</li></ul></li></ul> </div>
<div class="section section-3 " id="29004739_TCPSocketAPISpec-Ti.Network.Socket">
<h3 class="heading "><span>Ti.Network.Socket</span></h3>
<ul class=" "><li class=" "> <p>
Properties    </p>
<ul class=" "><li class=" "> <p>
<tt class=" ">INITIALIZED</tt> : Constant representing the &quot;initialized&quot; state a socket    </p>
</li><li class=" "> <p>
<tt class=" ">CONNECTED</tt> : Constant representing the &quot;connected&quot; state for a socket    </p>
</li><li class=" "> <p>
<tt class=" ">LISTENING</tt> : Constant representing the &quot;listening&quot; state for a socket    </p>
</li><li class=" "> <p>
<tt class=" ">CLOSED</tt> : Constant representing the &quot;closed&quot; state for a socket    </p>
</li><li class=" "> <p>
<tt class=" ">ERROR</tt> : Constant representing the &quot;error&quot; state for a socket    </p>
</li></ul></li><li class=" "> <p>
Functions    </p>
<ul class=" "><li class=" "> <p>
<tt class=" ">Ti.Network.Socket.TCP</tt> createTCP(Object args)}} : Creates a new TCP socket.    </p>
</li><li class=" "> <p>
<tt class=" ">Ti.Network.Socket.UDP</tt> createUDP(Object args)}} : Creates a new UDP socket.     <span style="color: #ff0000;">
RESERVED    </span>
; not intended to be implemented immediately.    </p>
</li></ul></li></ul> </div>
<div class="section section-3 " id="29004739_TCPSocketAPISpec-Ti.Network.Socket.TCP">
<h3 class="heading "><span>Ti.Network.Socket.TCP</span></h3>
<p>
While not currently used in this proposal, the &quot;options&quot; property name would be reserved for setting socket options in the future.    </p>
<ul class=" "><li class=" "> <p>
Properties    </p>
<ul class=" "><li class=" "> <p>
<tt class=" ">host</tt> : The host to connect to. <strong class=" ">Cannot</strong> be modified when not in the <tt class=" ">INITIALIZED</tt> state. Supports both IPv4 and IPv6.    </p>
</li><li class=" "> <p>
<tt class=" ">port</tt> : The port to connect to. <strong class=" ">Cannot</strong> be modified when not in the <tt class=" ">INITIALIZED</tt> state.    </p>
</li><li class=" "> <p>
<tt class=" ">listenQueueSize</tt> : Max number of pending incoming connections to be allowed when <tt class=" ">listen()</tt> is called. Any incoming connections received while the max number of pending connections has been reached will be rejected.    </p>
</li><li class=" "> <p>
<tt class=" ">timeout</tt> : The timeout for <tt class=" ">connect()</tt> and all I/O <tt class=" ">write()</tt> operations. <strong class=" ">Cannot</strong> be modified when not in the <tt class=" ">INITIALIZED</tt> state.    </p>
</li><li class=" "> <p>
<tt class=" ">options</tt> : Options for the socket (such as reuse, multicast, etc.)     <span style="color: #ff0000;">
RESERVED    </span>
; not to be implemented immediately.    </p>
</li><li class=" "> <p>
<tt class=" ">connected</tt> : The callback to be fired after the socket enters the &quot;connected&quot; state. Only invoked following a successful <tt class=" ">connect()</tt>call.    </p>
<ul class=" "><li class=" "> <p>
Argument parameters:    </p>
<ul class=" "><li class=" "> <p>
<tt class=" ">socket</tt> : The socket which was connected    </p>
</li></ul></li></ul></li><li class=" "> <p>
<tt class=" ">error</tt> : The callback to be fired after the socket enters the <tt class=" ">ERROR</tt>state.    </p>
<ul class=" "><li class=" "> <p>
Argument parameters:    </p>
<ul class=" "><li class=" "> <p>
<tt class=" ">socket</tt> : The socket that experienced the error    </p>
</li><li class=" "> <p>
<tt class=" ">error</tt> : A stringified description of the error    </p>
</li><li class=" "> <p>
<tt class=" ">errorCode</tt> : The error code of the error (potentially system-dependent)    </p>
</li></ul></li></ul></li><li class=" "> <p>
<tt class=" ">accepted</tt>: The callback to be fired when a listener accepts a connection.    </p>
<ul class=" "><li class=" "> <p>
Argument parameters:    </p>
<ul class=" "><li class=" "> <p>
<tt class=" ">socket</tt> : The socket which received the connection    </p>
</li><li class=" "> <p>
<tt class=" ">inbound</tt> : A <tt class=" ">Ti.Network.Socket</tt> object which represents the inbound connection; this should be considered a &quot;connected&quot; socket and is created in the CONNECTED state.    </p>
</li></ul></li></ul></li><li class=" "> <p>
<tt class=" ">state</tt>[spe:read-only] : The current state of the socket.    </p>
</li></ul></li></ul><ul class=" "><li class=" "> <p>
Functions    </p>
<ul class=" "><li class=" "> <p>
<tt class=" ">void connect()</tt> : Attempts to connect the socket to its host/port. Throws exception if the socket is in a CONNECTED or LISTENING state. Throws exception if a valid <tt class=" ">host</tt> and <tt class=" ">port</tt> has not been set on the proxy. Nonblocking; connection attempts are asynchronous.    </p>
</li><li class=" "> <p>
<tt class=" ">void listen()</tt> : Attempts to start listening on the socket's host/port. listen() call will attempt to listen on the specified host and/or port property for the socket if they are set. This function blocks execution and throws an exception on error (and sets the socket state to <tt class=" ">ERROR</tt>) but does not fire the <tt class=" ">error</tt> callback in this event. Throws exception if the socket is in a LISTENING or CONNECTED state.    </p>
</li><li class=" "> <p>
<tt class=" ">void accept(Object params)</tt> : Tells a <tt class=" ">LISTENING</tt> socket to accept a connection request at the top of a listener's request queue when one becomes available. Takes an argument, a box object which assigns callbacks to the created socket. Note that the <tt class=" ">connected</tt> callback is <strong class=" ">not</strong> called (the socket does not &quot;transition to&quot; the <tt class=" ">CONNECTED</tt> state - it's created in the <tt class=" ">CONNECTED</tt> state) on the newly created socket.  The accepted callback <strong class=" ">is</strong> called when a new connection is accepted as a result of calling accept().  If the socket is already flagged to accept the next connection, the existing accept options will be update to use the newly specified options object. Throws an exception if the socket is not in a LISTENING state.    </p>
</li><li class=" "> <p>
<tt class=" ">void close()</tt> : Closes a socket. Throws exception if the socket is not in a <tt class=" ">CONNECTED</tt> or <tt class=" ">LISTENING</tt> state. Blocking.    </p>
</li></ul></li></ul> </div>
</div>
<div class="section section-2 " id="29004739_TCPSocketAPISpec-PseudoCodeExamples">
<h2 class="heading "><span>Pseudo Code Examples</span></h2>
<div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="title">Create a socket to connect</div>
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="comments">/*</code></div>
<div class="line"><code class="comments"> * Assumes the existence of a `Ti.Blob Ti.createBlob(string text)` method</code></div>
<div class="line"><code class="comments"> */</code></div>
<div class="line"><code class="plain">var connectingSocket = Ti.Network.createTCP({</code></div>
<div class="line"><code class="plain">	host:</code><code class="string">'www.externalhost.com'</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	port:</code><code class="value">4747</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	connected:function(e) {</code></div>
<div class="line"><code class="plain">		e.socket.write(Ti.createBuffer({data: </code><code class="string">"Well, hello there!"</code><code class="plain">}));</code></div>
<div class="line"><code class="plain">	},</code></div>
<div class="line"><code class="plain">	error:function(e) {</code></div>
<div class="line"><code class="plain">		Ti.UI.createAlertDialog({</code></div>
<div class="line"><code class="plain">			title:</code><code class="string">"Socket error: "</code><code class="plain">+e.errorCode,</code></div>
<div class="line"><code class="plain">			message:e.error</code></div>
<div class="line"><code class="plain">		}).show();</code></div>
<div class="line"><code class="plain">		Ti.API.info(</code><code class="string">"CONNECTION has been closed: "</code><code class="plain">+e.socket.host+</code><code class="string">":"</code><code class="plain">+e.socket.port);</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="plain">connectingSocket.connect();</code></div>
</div>
</div><div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="title">Create a socket to listen</div>
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="comments">// NOTE: Under iOS, Ti.Platform.address always resolves to wifi; Android</code></div>
<div class="line"><code class="comments">// behavior may differ</code></div>
<div class="line"><code class="plain">var hostWhitelist = [</code><code class="string">'192.168.0.1'</code><code class="plain">, </code><code class="string">'192.168.0.2'</code><code class="plain">];</code></div>
<div class="line"><code class="plain">var connections = [];</code></div>
<div class="line"><code class="plain">var acceptedParams = {</code></div>
<div class="line"><code class="plain">	read: function(e) {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// Do something with data</code></div>
<div class="line"><code class="plain">	},</code></div>
<div class="line"><code class="plain">	error: function(e) {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// Do something with error</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"><code class="plain">var listeningSocket = Ti.Network.createTCP({</code></div>
<div class="line"><code class="plain">	host:Ti.Platform.address,</code></div>
<div class="line"><code class="plain">	port:</code><code class="value">4747</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	listenQueueSize:</code><code class="value">10</code><code class="plain">,	error:function(e) {</code></div>
<div class="line"><code class="plain">		Ti.UI.createAlertDialog({</code></div>
<div class="line"><code class="plain">			title:</code><code class="string">"Listener error: "</code><code class="plain">+e.errorCode,</code></div>
<div class="line"><code class="plain">			message:e.error</code></div>
<div class="line"><code class="plain">		}).show();</code></div>
<div class="line"><code class="plain">		Ti.API.info(</code><code class="string">"CONNECTION has been closed: "</code><code class="plain">+e.socket.host+</code><code class="string">":"</code><code class="plain">+e.socket.port);</code></div>
<div class="line"><code class="plain">	},</code></div>
<div class="line"><code class="plain">	accepted:function(e) {</code></div>
<div class="line"><code class="plain">		var socket = e.inbound;</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// NOTE: We only have the host information after accept()ing the</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// connection</code></div>
<div class="line"><code class="plain">		var whitelisted = hostWhitelist.indexOf(socket.host);</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (whitelisted == -</code><code class="value">1</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">			Ti.API.warn(</code><code class="string">"Attempted connection from socket not on whitelist: "</code><code class="plain">+socket.host);</code></div>
<div class="line"><code class="plain">			socket.close();</code></div>
<div class="line"><code class="plain">		}</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">			Ti.API.info(</code><code class="string">"Accepted connection from: "</code><code class="plain">+socket.host);</code></div>
<div class="line"><code class="plain">			connections.push(socket);</code></div>
<div class="line"><code class="plain">		}</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// Check for a maximum number of connections</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (connections.length &lt; </code><code class="value">10</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">			listeningSocket.accept(acceptedParams);</code></div>
<div class="line"><code class="plain">		}</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="keyword">try</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">	listeningSocket.listen();</code></div>
<div class="line"><code class="plain">	Ti.API.info(</code><code class="string">"Now listening on: "</code><code class="plain">+listeningSocket.host+</code><code class="string">":"</code><code class="plain">+listeningSocket.port);</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// NOTE: We do not block JS execution on 'accept', unlike BSD.</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// It is an asynch call which fires the 'accepted' callback when a</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// new inbound connection is available to be pulled off the queue.</code></div>
<div class="line"><code class="plain">	listeningSocket.accept(acceptedParams);</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"><code class="keyword">catch</code><code class="plain"> (e) {</code></div>
<div class="line"><code class="plain">	Ti.API.info(</code><code class="string">"Error occured while configuring listener: "</code><code class="plain">+e);</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"><code class="comments">// Maybe do something with connections somewhere...</code></div>
</div>
</div><div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="title">Current KS-&gt;Platform-&gt;Sockets example, using new sockets</div>
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="plain">var win = Titanium.UI.currentWindow;</code></div>
<div class="line"><code class="plain">var connectedSockets = [];</code></div>
<div class="line"><code class="plain">var acceptedCallbacks = {</code></div>
<div class="line"><code class="plain">	read: function(e) {</code></div>
<div class="line"><code class="plain">		messageLabel.text = </code><code class="string">"Read from: "</code><code class="plain">+e.socket.host;</code></div>
<div class="line"><code class="plain">		readLabel.text = e.data.text;</code></div>
<div class="line"><code class="plain">	},</code></div>
<div class="line"><code class="plain">	error : function(e) {</code></div>
<div class="line"><code class="plain">		Ti.UI.createAlertDialog({</code></div>
<div class="line"><code class="plain">			title:</code><code class="string">"Socket error: "</code><code class="plain">+e.socket.host,</code></div>
<div class="line"><code class="plain">			message:e.error</code></div>
<div class="line"><code class="plain">		}).show();</code></div>
<div class="line"><code class="plain">		var index = connectedSockets.indexOf(e.socket);</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (index != -</code><code class="value">1</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">			connectedSockets.splice(index,</code><code class="value">1</code><code class="plain">); </code><code class="comments">// Removes socket</code></div>
<div class="line"><code class="plain">		}</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"><code class="plain">var socket = Titanium.Network.createTCPSocket({</code></div>
<div class="line"><code class="plain">	hostName:Ti.Platform.address,</code></div>
<div class="line"><code class="plain">	port:</code><code class="value">40404</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	type:Ti.Network.TCP,</code></div>
<div class="line"><code class="plain">	accepted: function(e) {</code></div>
<div class="line"><code class="plain">		var sock = e.connector;</code></div>
<div class="line"><code class="plain">		connectedSockets.push(sock);</code></div>
<div class="line"><code class="plain">		socket.accept(acceptedCallbacks);</code></div>
<div class="line"><code class="plain">	},</code></div>
<div class="line"><code class="plain">	closed: function(e) {</code></div>
<div class="line"><code class="plain">		messageLabel.text = </code><code class="string">"Closed listener"</code><code class="plain">;</code></div>
<div class="line"><code class="plain">	},</code></div>
<div class="line"><code class="plain">	error: function(e) {</code></div>
<div class="line"><code class="plain">		Ti.UI.createAlertDialog({</code></div>
<div class="line"><code class="plain">			title:</code><code class="string">"Listener error: "</code><code class="plain">+e.errorCode,</code></div>
<div class="line"><code class="plain">			message:e.error</code></div>
<div class="line"><code class="plain">		}).show();</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="plain">var messageLabel = Titanium.UI.createLabel({</code></div>
<div class="line"><code class="plain">	text:</code><code class="string">'Socket messages'</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	font:{fontSize:</code><code class="value">14</code><code class="plain">},</code></div>
<div class="line"><code class="plain">	color:</code><code class="string">'#777'</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	top:</code><code class="value">220</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	left:</code><code class="value">10</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="plain">win.add(messageLabel);</code></div>
<div class="line"><code class="plain">var readLabel = Titanium.UI.createLabel({</code></div>
<div class="line"><code class="plain">	text:</code><code class="string">'Read data'</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	font:{fontSize:</code><code class="value">14</code><code class="plain">},</code></div>
<div class="line"><code class="plain">	color:</code><code class="string">'#777'</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	top:</code><code class="value">250</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	left:</code><code class="value">10</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	width:</code><code class="value">400</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="plain">win.add(readLabel);</code></div>
<div class="line"><code class="plain">var connectButton = Titanium.UI.createButton({</code></div>
<div class="line"><code class="plain">	title:</code><code class="string">'Listen on 40404'</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	width:</code><code class="value">200</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	height:</code><code class="value">40</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	top:</code><code class="value">10</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="plain">win.add(connectButton);</code></div>
<div class="line"><code class="plain">connectButton.addEventListener(</code><code class="string">'click'</code><code class="plain">, function() {</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">try</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">		socket.listen();</code></div>
<div class="line"><code class="plain">		messageLabel.text = </code><code class="string">"Listening on"</code><code class="plain">+e.socket.host+</code><code class="string">":"</code><code class="plain">+e.socket.port;</code></div>
<div class="line"><code class="plain">		e.socket.accept(acceptedCallbacks);</code></div>
<div class="line"><code class="plain">	} </code><code class="keyword">catch</code><code class="plain"> (e) {</code></div>
<div class="line"><code class="plain">		messageLabel.text = </code><code class="string">'Exception: '</code><code class="plain">+e;</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="plain">var closeButton = Titanium.UI.createButton({</code></div>
<div class="line"><code class="plain">	title:</code><code class="string">'Close'</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	width:</code><code class="value">200</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	height:</code><code class="value">40</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	top:</code><code class="value">60</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="plain">win.add(closeButton);</code></div>
<div class="line"><code class="plain">closeButton.addEventListener(</code><code class="string">'click'</code><code class="plain">, function() {</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">try</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">		socket.close();</code></div>
<div class="line"><code class="plain">	} </code><code class="keyword">catch</code><code class="plain"> (e) {</code></div>
<div class="line"><code class="plain">		messageLabel.text = </code><code class="string">'Exception: '</code><code class="plain">+e;</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="plain">var stateButton = Titanium.UI.createButton({</code></div>
<div class="line"><code class="plain">	title:</code><code class="string">'Socket state'</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	width:</code><code class="value">200</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	height:</code><code class="value">40</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	top:</code><code class="value">110</code></div>
<div class="line"><code class="plain">	});</code></div>
<div class="line"><code class="plain">win.add(validButton);</code></div>
<div class="line"><code class="plain">validButton.addEventListener(</code><code class="string">'click'</code><code class="plain">, function() {</code></div>
<div class="line"><code class="plain">	var stateString = </code><code class="string">"UNKNOWN"</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">switch</code><code class="plain"> (socket.state) {</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">case</code><code class="plain"> Ti.Network.SOCKET_INITIALIZED:</code></div>
<div class="line"><code class="plain">			stateString = </code><code class="string">"INITIALIZED"</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">case</code><code class="plain"> Ti.Network.SOCKET_CONNECTED:</code></div>
<div class="line"><code class="plain">			stateString = </code><code class="string">"CONNECTED"</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">case</code><code class="plain"> Ti.Network.SOCKET_LISTENING:</code></div>
<div class="line"><code class="plain">			stateString = </code><code class="string">"LISTENING"</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">case</code><code class="plain"> Ti.Network.SOCKET_CLOSED:</code></div>
<div class="line"><code class="plain">			stateString = </code><code class="string">"CLOSED"</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">case</code><code class="plain"> Ti.Network.SOCKET_ERROR:</code></div>
<div class="line"><code class="plain">			stateString = </code><code class="string">"ERROR"</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">	messageLabel.text = </code><code class="string">"State: "</code><code class="plain">+stateString;</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="plain">var writeButton = Titanium.UI.createButton({</code></div>
<div class="line"><code class="plain">	title:</code><code class="string">"Write 'Paradise Lost'"</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	width:</code><code class="value">200</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	height:</code><code class="value">40</code><code class="plain">,</code></div>
<div class="line"><code class="plain">	top:</code><code class="value">160</code></div>
<div class="line"><code class="plain">	});</code></div>
<div class="line"><code class="plain">win.add(writeButton);</code></div>
<div class="line"><code class="plain">writeButton.addEventListener(</code><code class="string">'click'</code><code class="plain">, function() {</code></div>
<div class="line"><code class="plain">	var plBlob = Titanium.Filesystem.getFile(Titanium.Filesystem.resourcesDirectory, </code><code class="string">'paradise_lost.txt'</code><code class="plain">).read();</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">for</code><code class="plain"> (var sock in connectedSockets) {</code></div>
<div class="line"><code class="plain">		sock.write(plBlob);</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">	messageLabel.text = </code><code class="string">"I'm a writer!"</code><code class="plain">;</code></div>
<div class="line"><code class="plain">});</code></div>
<div class="line"><code class="comments">// Cleanup</code></div>
<div class="line"><code class="plain">win.addEventListener(</code><code class="string">'close'</code><code class="plain">, function(e) {</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">try</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">		socket.close();</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">catch</code><code class="plain"> (e) {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// Don't care about exceptions; just means the socket was already closed</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">for</code><code class="plain"> (var sock in connectedSockets) {</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">try</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">			sock.close();</code></div>
<div class="line"><code class="plain">		}</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">catch</code><code class="plain"> (e) {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// See above</code></div>
<div class="line"><code class="plain">		}</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain">});</code></div>
</div>
</div> </div>
</div>
<div class="footer">
            Created with <a href="http://k15t.com/display/web/Scroll-Wiki-EclipseHelp-Exporter-for-Confluence" target="_blank">Scroll EclipseHelp Exporter for Confluence</a>.
        </div>
</div>
</body>
</html>
