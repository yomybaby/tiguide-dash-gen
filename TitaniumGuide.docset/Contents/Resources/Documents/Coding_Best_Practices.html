<!-- single file version -->
<!DOCTYPE html>
<html>
<head>
  <link href="css/github.css" rel="stylesheet" type="text/css">
  <link href="resources/css/common.css" rel="stylesheet" type="text/css">
  <meta charset="utf-8" />
</head>
<body>

<div class="container">
<div class="header"></div>
<div id="30082362" class="content">
<h1>Coding Best Practices</h1>
<p>
The Appcelerator-approved standard for mobile apps developed on the Titanium Mobile platform specifies a <strong class=" ">single-context</strong>, <strong class=" ">modular pattern</strong>, with <strong class=" ">well-structured code</strong>, and <strong class=" ">well-organized resources</strong>. By following these standards, developers will create apps that meet the preceding checklist of Stable, Rapid, Performant, and Readable.    </p>
<div class="section section-2 " id="30082362_CodingBestPractices-JavaScriptandgeneralrecommendations">
<h2 class="heading "><span>JavaScript and general recommendations</span></h2>
<div class="section section-3 " id="30082362_CodingBestPractices-Avoidtheglobalscope">
<h3 class="heading "><span>Avoid the global scope</span></h3>
<p>
Putting objects into the global scope can cause various problems:    </p>
<ul class=" "><li class=" "> <p>
Objects placed in the global scope will not be automatically garbage collected. You&apos;ll have to manually <tt class=" ">null</tt> global objects to mark them ready for collection.    </p>
</li><li class=" "> <p>
It&apos;s easy to inadvertently overwrite an object in the global scope, because that variable is accessible so widely within your program.    </p>
</li><li class=" "> <p>
The global scope of app.js is not accessible from other contexts or within CommonJS modules. So, you can&apos;t just dump variables there so you can access them throughout your app.    </p>
</li></ul> <p>
For these reasons, avoid defining variables in the global scope. Objects are placed in the global scope when:    </p>
<ul class=" "><li class=" "> <p>
You declare a variable outside of a function or CommonJS module. <i class=" ">Using a modular pattern will alleviate this problem.</i> </p>
</li><li class=" "> <p>
You omit the <tt class=" ">var</tt> keyword when declaring a variable (within or outside of a function). <i class=" ">So always use</i> <tt class=" ">var</tt> <i class=" ">when declaring variables.</i> </p>
</li></ul> </div>
<div class="section section-3 " id="30082362_CodingBestPractices-Avoidlocalobjectsinglobaleventlisteners">
<h3 class="heading "><span>Avoid local objects in global event listeners</span></h3>
<p>
The following code will cause a memory leak because the locally scoped variables are referenced in a global event listener. This is because the program will need to retain the locally scoped vars in order for the global event listener to use them. The global event listener will also persist until the app exits or the listener is explicitly removed.    </p>
<div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="plain">var someFunction = function() {</code></div>
<div class="line"><code class="plain">    var table = Ti.UI.createTableView(),</code></div>
<div class="line"><code class="plain">        label = Ti.UI.createLabel(),</code></div>
<div class="line"><code class="plain">        view = Ti.UI.createView();</code></div>
<div class="line"><code class="plain">    Ti.App.addEventListener(</code><code class="string">&apos;bad:move&apos;</code><code class="plain">, function(e) {</code></div>
<div class="line"><code class="plain">        table.setData(e.data);</code></div>
<div class="line"><code class="plain">    });</code></div>
<div class="line"><code class="plain">    view.add(table);</code></div>
<div class="line"><code class="plain">    view.add(label);</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">return</code><code class="plain"> view;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
</div> <p>
Global event listeners include those associated with Ti.App, Ti.Geolocation, Ti.Gesture, and so forth. The same problem is possible with non-global event listeners, like those you associate with a UI element. If that UI element remains valid in memory, any event listeners &#x2013; and the objects they refer to &#x2013; must also be kept in memory.    </p>
<p>
The above example is an anti-pattern that will eventually consume the app&apos;s available memory. It&apos;s important to note that this is a common anti-pattern that developers employ in browser-based environments too, where it causes the same result, so it is not unique to Titanium.    </p>
<p>
If you need to have a custom event, consider a method / callback that you can invoke later on. For the global events like location, network change, etc. it&apos;s highly recommended to place them in app.js. The general rule of thumb is global events handle global objects.    </p>
</div>
<div class="section section-3 " id="30082362_CodingBestPractices-Donotnamecustomeventswithspaces">
<h3 class="heading "><span>Do not name custom events with spaces</span></h3>
<p>
Using spaces to name custom events may cause issues with other JavaScript libraries, such as Backbone.js, which uses spaces to delimit events.  Naming events with spaces may cause events to fire multiple times.  For example, instead of naming a custom event as &quot;my event&quot;, use &quot;my:event&quot; or &quot;my_event&quot;.    </p>
</div>
<div class="section section-3 " id="30082362_CodingBestPractices-Deferscriptloading">
<h3 class="heading "><span>Defer script loading</span></h3>
<p>
One of the bottlenecks of a Titanium application is JavaScript evaluation. This is particularly the case for Android, although the V8 runtime provides substantial improvements for this issue compared with Rhino. For that reason, to speed the startup and responsiveness of your application, you should avoid loading scripts until they are absolutely needed. As in the following application, which has three windows to be opened in succession on a click (touch) event, note that the dependent JavaScript for each window is not loaded until absolutely necessary.    </p>
<div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="title">Lazy script loading in app.js</div>
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="comments">//muse be loaded at launch</code></div>
<div class="line"><code class="plain">var WindowOne = require(</code><code class="string">&apos;ui/WindowOne&apos;</code><code class="plain">).WindowOne;</code></div>
<div class="line"><code class="plain">var win1 = </code><code class="keyword">new</code><code class="plain"> WindowOne();</code></div>
<div class="line"><code class="plain">win1.open();</code></div>
<div class="line"><code class="plain">win1.addEventListener(</code><code class="string">&apos;click&apos;</code><code class="plain">, function() {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">//load window two JavaScript when needed...</code></div>
<div class="line"><code class="plain">  var WindowTwo = require(</code><code class="string">&apos;ui/WindowTwo&apos;</code><code class="plain">).WindowTwo;</code></div>
<div class="line"><code class="plain">  var win2 = </code><code class="keyword">new</code><code class="plain"> WindowTwo();</code></div>
<div class="line"><code class="plain">  win2.open();</code></div>
<div class="line"><code class="plain">  win2.addEventListener(</code><code class="string">&apos;click&apos;</code><code class="plain">, function() {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">//load window three JavaScript when needed...</code></div>
<div class="line"><code class="plain">    var WindowThree = require(</code><code class="string">&apos;ui/WindowThree&apos;</code><code class="plain">).WindowThree;</code></div>
<div class="line"><code class="plain">    var win3 = </code><code class="keyword">new</code><code class="plain"> WindowTwo();</code></div>
<div class="line"><code class="plain">    win3.open();</code></div>
<div class="line"><code class="plain">  });</code></div>
<div class="line"><code class="plain">});</code></div>
</div>
</div> <p>
Or, if you&apos;re not using CommonJS but building out a namespace:    </p>
<div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="title">Deferred loading to build a namespace</div>
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="plain">var someNameSpace = function() {</code></div>
<div class="line"><code class="plain">	var API = {</code></div>
<div class="line"><code class="plain">		init: function() {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// create your UI here or do whatever</code></div>
<div class="line"><code class="plain">		}</code></div>
<div class="line"><code class="plain">		reset: function() {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// null objects, clean up, etc</code></div>
<div class="line"><code class="plain">		}</code></div>
<div class="line"><code class="plain">	};</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// Construct anything you want outside the local &apos;API&apos; object</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">return</code><code class="plain"> API;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"><code class="comments">// And to use it</code></div>
<div class="line"><code class="plain">var test = </code><code class="keyword">new</code><code class="plain"> someNameSpace();</code></div>
</div>
</div> </div>
</div>
<div class="section section-2 " id="30082362_CodingBestPractices-Titanium-specificRecommendations">
<h2 class="heading "><span>Titanium-specific Recommendations</span></h2>
<div class="section section-3 " id="30082362_CodingBestPractices-Don&apos;tExtendTitaniumPrototypes">
<h3 class="heading "><span>Don&apos;t Extend Titanium Prototypes</span></h3>
<p>
Many users attempt to add to the Ti namespace as a means to persist data across contexts, extend / override native methods, etc. This can sometimes work but is very unreliable for the following reasons:    </p>
<ol class=" "><li class=" "> <p>
The Titanium end objects are really not true JavaScript objects. They are proxy representations of native operating system components. As such, they are constructed to pass through properties and method invocations. Your extensions could conflict with native functionality or interfere with proper operation of the proxy objects.    </p>
</li><li class=" "> <p>
Sometimes you might be able to store things on the namespace but it&apos;s not changeable (i.e. an array stored on the namespace might not be able to be modified - mutable, etc.). Other-times your stored objects will be completely null.    </p>
</li><li class=" "> <p>
Since this isn&apos;t an approved way of storing anything, there&apos;s no guarantee it will work in future releases of Titanium.    </p>
</li></ol> <p>
As a rule do not add to, or extend via the prototype, any object or module in the Titanium namespace. If you want to extend a core part of the Titanium API you should build a native module to accomplish this. If you&apos;re just looking for an extendible JS namespace, create your own (i.e. {{var MyApp={} }}).    </p>
</div>
<div class="section section-3 " id="30082362_CodingBestPractices-Codingstrategiesformultiplatformapps">
<h3 class="heading "><span>Coding strategies for multiplatform apps</span></h3>
<p>
Branching in code is useful when your code will be <i class=" ">mostly the same</i> across platforms, but vary here and there. Long blocks of if...then code are difficult to read and maintain. Also, excessive branching will slow your app&apos;s execution. If you must use this technique, try to group as much code as you can within a branch and defer loading as much as possible to mitigate the performance penalty of branching.    </p>
<p>
Using platform-specific JS files is likely to be most useful when your code is <i class=" ">mostly different</i> across platforms. This removes long if...then blocks from your main code. Separating platform-specific code reduces the chances of an error that comes from accidentally using the wrong platform&apos;s API or property. However, you&apos;ll have to remember to apply changes and fixes to <i class=" ">each</i> of the platform-specific files. So this approach could increase your work rather than reduce it.    </p>
<p>
See <a class="document-link " href="#!/guide/Supporting_Multiple_Platforms_in_a_Single_Codebase" supporting_multiple_platforms_in_a_single_codebase.html="Supporting_Multiple_Platforms_in_a_Single_Codebase.html">Supporting Multiple Platforms in a Single Codebase</a> for more information and code examples.    </p>
</div>
<div class="section section-3 " id="30082362_CodingBestPractices-Don&apos;tstoresensitivedatainnon-JavaScriptfiles">
<h3 class="heading "><span>Don&apos;t store sensitive data in non-JavaScript files</span></h3>
<p>
Your JavaScript files are minified and obfuscated when you build for distribution. Depending on your target platform, they will be further processed and packaged into the compiled or &quot;object-ified&quot; files of your app. However, images, JSON files, SQLite databases, and other files not named with a .js extension are simply packaged as-is with your app&apos;s files.    </p>
<p>
APK and IPA files are essentially Zip files. Their contents can be revealed by any Zip-decompressor. Thus, your non-JavaScript files are accessible to the curious.    </p>
<p>
You should not include sensitive data in non-JS files. Simply renaming files with a .js extension is not a suitable alternative. Such files might not be supported on device. And, the Titanium build process removes them from the final build.    </p>
</div>
<div class="section section-3 " id="30082362_CodingBestPractices-Setlocalvariablestoavoidcallingnativemethods">
<h3 class="heading "><span>Set local variables to avoid calling native methods</span></h3>
<p>
Each time you request the value of a device-related property, Titanium has to query the operating system for the value. For example, if you read from <tt class=" ">Ti.Platform.osname</tt> or <tt class=" ">Ti.Platform.displayCaps.platformHeight</tt>, Titanium must take a &quot;trip across the bridge&quot; to request the value from the operating system. Doing so takes a few cycles and if used too frequently could possibly slow your program. Something like the following would be more efficient:    </p>
<div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="plain">var isAndroid = (Ti.Platform.osname==</code><code class="string">&apos;android&apos;</code><code class="plain">) ? </code><code class="keyword">true</code><code class="plain"> : </code><code class="keyword">false</code><code class="plain">;</code></div>
<div class="line"><code class="keyword">if</code><code class="plain">(isAndroid) {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// do Android specific stuff</code></div>
<div class="line"><code class="plain">} </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// do iOS stuff</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
</div> </div>
</div>
<div class="section section-2 " id="30082362_CodingBestPractices-AppArchitectureRecommendations">
<h2 class="heading "><span>App Architecture Recommendations</span></h2>
<div class="section section-3 " id="30082362_CodingBestPractices-ModularcomponentswithCommonJS">
<h3 class="heading "><span>Modular components with CommonJS</span></h3>
<p>
Appcelerator&apos;s primary recommended architecture a modular app architecture constructed with CommonJS modules. In fact, we have a whole Best Practices section devoted to <a class="document-link " href="#!/guide/CommonJS_Modules_in_Titanium" commonjs_modules_in_titanium.html="CommonJS_Modules_in_Titanium.html">CommonJS Modules in Titanium</a>. CommonJS modules are discrete and independent building blocks, eliminating concerns about global variables and naming conflicts. In our testing, it is a highly performant architecture compared to some other solutions. This pattern is also used by other JavaScript-based environments, such as Node.js.    </p>
<div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="title">MyModule.js</div>
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="comments">// variables defined in this file are private</code></div>
<div class="line"><code class="plain">var defaultMessage = </code><code class="string">&quot;Hello world&quot;</code><code class="plain">;</code></div>
<div class="line"><code class="comments">// we make objects, variables, functions available to the</code></div>
<div class="line"><code class="comments">// calling context by adding them to the exports object</code></div>
<div class="line"><code class="plain">exports.sayHello = function(msg) {</code></div>
<div class="line"><code class="plain">	Ti.API.info(</code><code class="string">&apos;Hello &apos;</code><code class="plain">+msg);</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"><code class="comments">// we can assign other objects, functions, and variables to</code></div>
<div class="line"><code class="comments">// exports and they will be available to the calling context</code></div>
<div class="line"><code class="plain">exports.helloWorld = function() {</code></div>
<div class="line"><code class="plain">	Ti.API.info(defaultMessage);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
</div><div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="title">app.js</div>
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="plain">var myModule = require(</code><code class="string">&apos;/MyModule&apos;</code><code class="plain">);</code></div>
<div class="line"><code class="plain">myModule.sayHello(</code><code class="string">&apos;Kevin&apos;</code><code class="plain">);  </code><code class="comments">//console output is &quot;Hello Kevin!&quot;</code></div>
</div>
</div> <p>
Other architectures are valid and meet the needs of many developers. Which you choose is ultimately up to you and your experiences    </p>
<div class="section section-4 " id="30082362_CodingBestPractices-Customobjectsascomponents">
<h4 class="heading "><span>Custom objects as components</span></h4>
<p>
Another popular pattern is one we teach in our training classes, that of custom objects typically stored within an app-specific namespace hierarchy. This model is flexible and well-suited to rapid deployment projects. It takes advantage of JavaScript&apos;s language features. Components are all members of the same global scope, thus sharing data within the app is simple. And when implemented well, this pattern can lead to very readable (and thus maintainable) code.    </p>
<p>
On the downside, this pattern is less performant than CommonJS modules, especially on Rhino/Android. The rapid nature of this pattern can lead the developer to general, high-level bad practices and developer &apos;laziness&apos;. Inheritance is vague or even non-existent. And critically, memory management can be difficult as object references can remain after they&apos;re no longer needed.    </p>
<div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="comments">// create an object literal to be your app&apos;s namespace</code></div>
<div class="line"><code class="plain">var myapp = {};</code></div>
<div class="line"><code class="comments">// the following could be in a separate &quot;ui.js&quot; file and include()&apos;d into your app.js</code></div>
<div class="line"><code class="plain">(function(){</code></div>
<div class="line"><code class="plain">	myapp.ui = {}; </code><code class="comments">// this sub-namespace extends the app&apos;s namespace object</code></div>
<div class="line"><code class="plain">	myapp.ui.createApplicationWindow = function() {</code></div>
<div class="line"><code class="plain">		var win = Ti.UI.createWindow({</code></div>
<div class="line"><code class="plain">			backgroundColor:</code><code class="string">&apos;white&apos;</code></div>
<div class="line"><code class="plain">		});</code></div>
<div class="line"><code class="plain">		var header = Ti.UI.createLabel({</code></div>
<div class="line"><code class="plain">			text: </code><code class="string">&apos;My App Heading&apos;</code><code class="plain">,</code></div>
<div class="line"><code class="plain">			top: </code><code class="value">10</code></div>
<div class="line"><code class="plain">		});</code></div>
<div class="line"><code class="plain">		win.add(header);</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">return</code><code class="plain"> win;</code></div>
<div class="line"><code class="plain">	};</code></div>
<div class="line"><code class="plain">})();</code></div>
</div>
</div> <p>
The same could be accomplished without the self-calling function, if you prefer:    </p>
<div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="comments">// create an object literal to be your app&apos;s namespace</code></div>
<div class="line"><code class="plain">var myapp = {};</code></div>
<div class="line"><code class="comments">// the following could be in a separate &quot;ui.js&quot; file and include()&apos;d into your app.js</code></div>
<div class="line"><code class="plain">myapp.ui = function() {</code></div>
<div class="line"><code class="plain">	var API = {</code></div>
<div class="line"><code class="plain">		createApplicationWindow: function() {</code></div>
<div class="line"><code class="plain">			var win = Ti.UI.createWindow({</code></div>
<div class="line"><code class="plain">				backgroundColor:</code><code class="string">&apos;white&apos;</code></div>
<div class="line"><code class="plain">			});</code></div>
<div class="line"><code class="plain">			var header = Ti.UI.createLabel({</code></div>
<div class="line"><code class="plain">				text: </code><code class="string">&apos;My App Heading&apos;</code><code class="plain">,</code></div>
<div class="line"><code class="plain">				top: </code><code class="value">10</code></div>
<div class="line"><code class="plain">			});</code></div>
<div class="line"><code class="plain">			win.add(header);</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">return</code><code class="plain"> win;</code></div>
<div class="line"><code class="plain">		}</code></div>
<div class="line"><code class="plain">	}</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">return</code><code class="plain"> API;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
</div> </div>
<div class="section section-4 " id="30082362_CodingBestPractices-Classical-basedpatterns">
<h4 class="heading "><span>Classical-based patterns</span></h4>
<p>
In general, Appcelerator does not recommend classical-inheritance based models because JavaScript is not a class-based language. For an in-depth look at inheritance patterns in JavaScript, we recommend you read Douglas Crockford&apos;s <a class="external-link external-link" href="http://javascript.crockford.com/prototypal.html" target="_blank">Protypal Inheritance in JavaScript</a> and <a class="external-link external-link" href="http://javascript.crockford.com/inheritance.html" target="_blank">Classical Inheritance in JavaScript</a> articles.    </p>
<p>
Classical inheritance is familiar for programmers coming from Java and other class-based languages. They rightly claim that this pattern enforces discipline and logically structured code that is generally easy to read, debug, and document. However, it&apos;s our belief that such a pattern confuses the idea of &apos;classes&apos; and &apos;objects&apos; in Javascript, forces the programmer to define his or her own inheritance rules, and is slower to implement in a rapid-prototype setting.    </p>
<p>
The code below is a fragment of this pattern:    </p>
<div xmlns="http://www.w3.org/1999/xhtml" class="confbox programlisting scroll-unprocessed">
<div class="defaultnew syntaxhighlighter">
<div class="line"><code class="plain">var SomeUIClass = function() {</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// ----- DEFINE PRIVATE PROPERTIES AND METHODS -----</code></div>
<div class="line"><code class="plain">	var UIGroup = Ti.UI.createView({ zIndex:</code><code class="value">5</code><code class="plain"> }),</code></div>
<div class="line"><code class="plain">	    UIBg = Ti.UI.createView({ borderRadius:</code><code class="value">10</code><code class="plain">, opacity:</code><code class="value">0.2</code><code class="plain">, width:</code><code class="value">150</code><code class="plain">, height:</code><code class="value">150</code><code class="plain">, backgroundColor:</code><code class="string">&quot;#000&quot;</code><code class="plain"> }),</code></div>
<div class="line"><code class="plain">	    UIInd = Ti.UI.createActivityIndicator({ height:</code><code class="value">50</code><code class="plain">, width:</code><code class="value">50</code><code class="plain">, bottom:</code><code class="value">175</code><code class="plain">, style:Ti.UI.iPhone.ActivityIndicatorStyle.BIG });</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// ----- DEFINE PUBLIC PROPERTIES AND METHODS -----</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// ----- Public Properties -----</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">this</code><code class="plain">.somePublicProp = </code><code class="keyword">null</code><code class="plain">;</code></div>
<div class="line"><code class="plain"> </code><code class="comments">// ----- Public Methods -----</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">this</code><code class="plain">.display = function() {};</code></div>
<div class="line"><code class="plain"> </code><code class="keyword">this</code><code class="plain">.toggle = function(toggle) {};</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
</div> </div>
</div>
</div>
</div>

</div>

</body>
</html>